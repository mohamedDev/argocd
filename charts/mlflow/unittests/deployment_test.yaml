suite: test deployment

templates:
  - configmap.yaml
  - deployment.yaml

release:
  name: mlflow
  namespace: mlflow

chart:
  version: 1.0.0
  appVersion: 1.0.0

tests:
  - it: should be custom service account when we do not create it
    set:
      serviceAccount.create: false
      serviceAccount.name: customsa
    asserts:
      - equal:
          path: spec.template.spec.serviceAccountName
          value: customsa
        template: deployment.yaml

  - it: should be a memory backend when Postgres or MySQL or bitnami Postgres or bitnami MySQL are not enabled
    asserts:
      - contains:
          path: spec.template.spec.containers[?(@.name == "mlflow")].args
          content: "--backend-store-uri=sqlite:///:memory:"
        template: deployment.yaml

  - it: should be a defined sqlite path backend when Postgres or MySQL or bitnami Postgres or bitnami MySQL are not enabled and sqlite path is defined
    set:
      backendStore.defaultSqlitePath: /mlflow/data/mlflow.db
    asserts:
      - contains:
          path: spec.template.spec.containers[?(@.name == "mlflow")].args
          content: "--backend-store-uri=sqlite:////mlflow/data/mlflow.db"
        template: deployment.yaml

  - it: should be Postgres backend when Postgres is enabled
    set:
      backendStore:
        postgres:
          enabled: true
          host: test-host
          database: test-database
          driver: ""
    asserts:
      - contains:
          path: spec.template.spec.containers[?(@.name == "mlflow")].args
          content: --backend-store-uri=postgresql://
        template: deployment.yaml

  - it: should be Postgressql backend when postgresql is enabled
    set:
      postgresql:
        enabled: true
    asserts:
      - contains:
          path: spec.template.spec.containers[?(@.name == "mlflow")].args
          content: --backend-store-uri=postgresql://
        template: deployment.yaml

  - it: should use DB connection driver with Postgres backend when Postgres is enabled and driver defined
    set:
      backendStore:
        postgres:
          enabled: true
          host: test-host
          database: test-database
          driver: "psycopg2"
    asserts:
      - contains:
          path: spec.template.spec.containers[?(@.name == "mlflow")].args
          content: --backend-store-uri=postgresql+psycopg2://
        template: deployment.yaml

  - it: should be MySQL backend when MySQL is enabled
    set:
      backendStore:
        mysql:
          enabled: true
          host: test-host
          database: test-database
          driver: ""
    asserts:
      - contains:
          path: spec.template.spec.containers[?(@.name == "mlflow")].args
          content: --backend-store-uri=mysql://$(MYSQL_USERNAME):$(MYSQL_PWD)@$(MYSQL_HOST):$(MYSQL_TCP_PORT)/$(MYSQL_DATABASE)
        template: deployment.yaml

  - it: should be MySQL backend when bitnami mysql is enabled
    set:
      mysql:
        enabled: true
      backendStore:
        mysql:
          driver: ""
    asserts:
      - contains:
          path: spec.template.spec.containers[?(@.name == "mlflow")].args
          content: --backend-store-uri=mysql://$(MYSQL_USERNAME):$(MYSQL_PWD)@$(MYSQL_HOST):$(MYSQL_TCP_PORT)/$(MYSQL_DATABASE)
        template: deployment.yaml

  - it: should use DB connection driver with MySQL backend when MySQL is enabled and driver defined
    set:
      backendStore:
        mysql:
          enabled: true
          host: test-host
          database: test-database
          driver: "pymysql"
    asserts:
      - contains:
          path: spec.template.spec.containers[?(@.name == "mlflow")].args
          content: --backend-store-uri=mysql+pymysql://$(MYSQL_USERNAME):$(MYSQL_PWD)@$(MYSQL_HOST):$(MYSQL_TCP_PORT)/$(MYSQL_DATABASE)
        template: deployment.yaml

  - it: should use DB connection driver with MySQL backend when bitnami mysql is enabled and driver defined
    set:
      mysql:
        enabled: true
      backendStore:
        mysql:
          driver: "pymysql"
    asserts:
      - contains:
          path: spec.template.spec.containers[?(@.name == "mlflow")].args
          content: --backend-store-uri=mysql+pymysql://$(MYSQL_USERNAME):$(MYSQL_PWD)@$(MYSQL_HOST):$(MYSQL_TCP_PORT)/$(MYSQL_DATABASE)
        template: deployment.yaml

  - it: should be local folder as an artifact root when azureBlob or s3 or gcs is not enabled
    asserts:
      - contains:
          path: spec.template.spec.containers[?(@.name == "mlflow")].args
          content: --default-artifact-root=./mlruns
        template: deployment.yaml

  - it: should be a defined artifact root when azureBlob or s3 or gcs is not enabled and artifact root is defined
    set:
      artifactRoot.defaultArtifactRoot: http://my-mlflowserver.com/api/2.0/mlflow-artifacts/artifacts/experiments
    asserts:
      - contains:
          path: spec.template.spec.containers[?(@.name == "mlflow")].args
          content: --default-artifact-root=http://my-mlflowserver.com/api/2.0/mlflow-artifacts/artifacts/experiments
        template: deployment.yaml

  - it: should be azureBlob as an artifact root when azureBlob is enabled
    set:
      artifactRoot:
        azureBlob:
          enabled: true
          container: test-container
          storageAccount: test-account
          path: mlflow_folder
    asserts:
      - contains:
          path: spec.template.spec.containers[?(@.name == "mlflow")].args
          content: --default-artifact-root=wasbs://test-container@test-account.blob.core.windows.net/mlflow_folder
        template: deployment.yaml

  - it: should be s3 as an artifact root when s3 is enabled
    set:
      artifactRoot:
        s3:
          enabled: true
          bucket: test-bucket
          path: mlflow_folder
    asserts:
      - contains:
          path: spec.template.spec.containers[?(@.name == "mlflow")].args
          content: --default-artifact-root=s3://test-bucket/mlflow_folder
        template: deployment.yaml

  - it: should be gcs as an artifact root when gcs is enabled
    set:
      artifactRoot:
        gcs:
          enabled: true
          bucket: test-bucket
          path: mlflow_folder
    asserts:
      - contains:
          path: spec.template.spec.containers[?(@.name == "mlflow")].args
          content: --default-artifact-root=gs://test-bucket/mlflow_folder
        template: deployment.yaml

  - it: should be local folder as an artifact destination when proxy enabled and azureBlob or s3 or gcs is not enabled
    set:
      artifactRoot.proxiedArtifactStorage: true
    asserts:
      - contains:
          path: spec.template.spec.containers[?(@.name == "mlflow")].args
          content: --artifacts-destination=./mlartifacts
        template: deployment.yaml
      - contains:
          path: spec.template.spec.containers[?(@.name == "mlflow")].args
          content: --serve-artifacts
        template: deployment.yaml

  - it: should be a defined artifact destination when proxy enabled and azureBlob or s3 or gcs is not enabled and artifact destination is defined
    set:
      artifactRoot:
        proxiedArtifactStorage: true
        defaultArtifactsDestination: /mlflow/data/mlartifacts
    asserts:
      - contains:
          path: spec.template.spec.containers[?(@.name == "mlflow")].args
          content: --artifacts-destination=/mlflow/data/mlartifacts
        template: deployment.yaml
      - contains:
          path: spec.template.spec.containers[?(@.name == "mlflow")].args
          content: --serve-artifacts
        template: deployment.yaml

  - it: should be azureBlob as an artifact destination when proxy enabled and azureBlob is enabled
    set:
      artifactRoot:
        proxiedArtifactStorage: true
        azureBlob:
          enabled: true
          container: test-container
          storageAccount: test-account
          path: mlflow_folder
    asserts:
      - contains:
          path: spec.template.spec.containers[?(@.name == "mlflow")].args
          content: --artifacts-destination=wasbs://test-container@test-account.blob.core.windows.net/mlflow_folder
        template: deployment.yaml
      - contains:
          path: spec.template.spec.containers[?(@.name == "mlflow")].args
          content: --serve-artifacts
        template: deployment.yaml

  - it: should be s3 as an artifact destination when proxy enabled and s3 is enabled
    set:
      artifactRoot:
        proxiedArtifactStorage: true
        s3:
          enabled: true
          bucket: test-bucket
          path: mlflow_folder
    asserts:
      - contains:
          path: spec.template.spec.containers[?(@.name == "mlflow")].args
          content: --artifacts-destination=s3://test-bucket/mlflow_folder
        template: deployment.yaml
      - contains:
          path: spec.template.spec.containers[?(@.name == "mlflow")].args
          content: --serve-artifacts
        template: deployment.yaml

  - it: should be gcs as an artifact destination when proxy enabled and gcs is enabled
    set:
      artifactRoot:
        proxiedArtifactStorage: true
        gcs:
          enabled: true
          bucket: test-bucket
          path: mlflow_folder
    asserts:
      - contains:
          path: spec.template.spec.containers[?(@.name == "mlflow")].args
          content: --artifacts-destination=gs://test-bucket/mlflow_folder
        template: deployment.yaml
      - contains:
          path: spec.template.spec.containers[?(@.name == "mlflow")].args
          content: --serve-artifacts
        template: deployment.yaml

  - it: should expose prometheus metrics when serviceMonitor is enabled
    set:
      serviceMonitor.enabled: true
    asserts:
      - contains:
          path: spec.template.spec.containers[?(@.name == "mlflow")].args
          content: --expose-prometheus=/mlflow/metrics
        template: deployment.yaml

  - it: should set log level to gunicorn when log level is set and gunicornOpts is not set
    set:
      log:
        enabled: true
        level: debug
    asserts:
      - contains:
          path: spec.template.spec.containers[?(@.name == "mlflow")].args
          content: --gunicorn-opts='--log-level=debug'
        template: deployment.yaml

  - it: should set log level to gunicorn when log level is set and gunicornOpts is set without log level
    set:
      log:
        enabled: true
        level: debug
      extraArgs:
        gunicornOpts: "--workers=4"
    asserts:
      - contains:
          path: spec.template.spec.containers[?(@.name == "mlflow")].args
          content: --gunicorn-opts='--log-level=debug --workers=4'
        template: deployment.yaml

  - it: should set log level to gunicorn when log level is set and gunicornOpts is set with different log level
    set:
      log:
        enabled: true
        level: debug
      extraArgs:
        gunicornOpts: "--log-level=info --workers=4"
    asserts:
      - contains:
          path: spec.template.spec.containers[?(@.name == "mlflow")].args
          content: --gunicorn-opts='--log-level=debug --workers=4'
        template: deployment.yaml

  - it: should show extra arguments when we pass any
    set:
      extraArgs:
        workers: "4"
        staticPrefix: "/mlflow"
    asserts:
      - contains:
          path: spec.template.spec.containers[?(@.name == "mlflow")].args
          content: --workers=4
        template: deployment.yaml
      - contains:
          path: spec.template.spec.containers[?(@.name == "mlflow")].args
          content: --static-prefix=/mlflow
        template: deployment.yaml

  - it: should show extra flags when we pass any
    set:
      extraFlags:
        - serveArtifacts
        - artifactsOnly
    asserts:
      - contains:
          path: spec.template.spec.containers[?(@.name == "mlflow")].args
          content: --serve-artifacts
        template: deployment.yaml
      - contains:
          path: spec.template.spec.containers[?(@.name == "mlflow")].args
          content: --artifacts-only
        template: deployment.yaml

  - it: should show mlflow version environment variable
    chart:
      version: 0.1.62
      appVersion: 1.27.0
    asserts:
      - contains:
          path: spec.template.spec.containers[?(@.name == "mlflow")].env
          content:
            name: MLFLOW_VERSION
            value: "1.27.0"
        template: deployment.yaml

  - it: should show extra environment variables when we pass any
    set:
      extraEnvVars:
         MLFLOW_S3_IGNORE_TLS: true
         AWS_DEFAULT_REGION: eu-central-1
    asserts:
      - contains:
          path: spec.template.spec.containers[?(@.name == "mlflow")].env
          content:
            name: MLFLOW_S3_IGNORE_TLS
            value: "true"
        template: deployment.yaml
      - contains:
          path: spec.template.spec.containers[?(@.name == "mlflow")].env
          content:
            name: AWS_DEFAULT_REGION
            value: eu-central-1
        template: deployment.yaml

  - it: should show extra secret environment variables from secrets when we pass any
    set:
      extraSecretNamesForEnvFrom:
        - mysupersecret
    asserts:
      - contains:
          path: spec.template.spec.containers[?(@.name == "mlflow")].envFrom
          content: 
            secretRef:
              name: mysupersecret
        template: deployment.yaml

  - it: should check liveness and rediness with static prefix when we set static prefix from extra arguments
    set:
      extraArgs:
        staticPrefix: /mlflow
    asserts:
      - equal:
          path: spec.template.spec.containers[?(@.name == "mlflow")].livenessProbe.httpGet.path
          value: /mlflow/health
        template: deployment.yaml
      - equal:
          path: spec.template.spec.containers[?(@.name == "mlflow")].readinessProbe.httpGet.path
          value: /mlflow/health
        template: deployment.yaml
  
  - it: should check that the db checker init container is present if enabled with postgres
    set:
      backendStore:
        databaseConnectionCheck: true
        postgres:
          enabled: true
          host: test-host
          database: test-database
          user: test-user
          password: test-password
    asserts:
      - equal:
          path: spec.template.spec.initContainers[0].name
          value: dbchecker
        template: deployment.yaml
  
  - it: should check that the db checker init container is present if enabled with postgresql
    set:
      postgresql:
        enabled: true
        auth:
          username: test-user
          password: test-password
          database: test-database
      backendStore:
        databaseConnectionCheck: true
    asserts:
      - equal:
          path: spec.template.spec.initContainers[0].name
          value: dbchecker
        template: deployment.yaml

  - it: should check that the db checker init container is present if enabled with mysql
    set:
      backendStore:
        databaseConnectionCheck: true
        mysql:
          enabled: true
          host: test-host
          database: test-database
          user: test-user
          password: test-password
    asserts:
      - equal:
          path: spec.template.spec.initContainers[0].name
          value: dbchecker
        template: deployment.yaml

  - it: should check that the db checker init container is present if enabled with bitnami mysql
    set:
      mysql:
        enabled: true
        auth:
          username: test-user
          password: test-password
      backendStore:
        databaseConnectionCheck: true
    asserts:
      - equal:
          path: spec.template.spec.initContainers[0].name
          value: dbchecker
        template: deployment.yaml
  
  - it: should check that the db checker and additional init containers are present with postgres
    set:
      initContainers:
        - name: init-container-test
          image: test:3.2
          command:
            - sleep
            - infinity
      backendStore:
        databaseConnectionCheck: true
        postgres:
          enabled: true
          host: test-host
          database: test-database
          user: test-user
          password: test-password
    asserts:
      - equal:
          path: spec.template.spec.initContainers[0].name
          value: dbchecker
        template: deployment.yaml
      - equal:
          path: spec.template.spec.initContainers[1].name
          value: init-container-test
        template: deployment.yaml
  
  - it: should check that the db checker and additional init containers are present with postgresql
    set:
      initContainers:
        - name: init-container-test
          image: test:3.2
          command:
            - sleep
            - infinity
      postgresql:
        enabled: true
        auth:
          database: test-database
          username: test-user
          password: test-password
      backendStore:
        databaseConnectionCheck: true
    asserts:
      - equal:
          path: spec.template.spec.initContainers[0].name
          value: dbchecker
        template: deployment.yaml
      - equal:
          path: spec.template.spec.initContainers[1].name
          value: init-container-test
        template: deployment.yaml

  - it: should check that the db checker and additional init containers are present with mysql
    set:
      initContainers:
        - name: init-container-test
          image: test:3.2
          command:
            - sleep
            - infinity
      backendStore:
        databaseConnectionCheck: true
        mysql:
          enabled: true
          host: test-host
          database: test-database
          user: test-user
          password: test-password
    asserts:
      - equal:
          path: spec.template.spec.initContainers[0].name
          value: dbchecker
        template: deployment.yaml
      - equal:
          path: spec.template.spec.initContainers[1].name
          value: init-container-test
        template: deployment.yaml

  - it: should check that the db checker and additional init containers are present with bitnami mysql
    set:
      initContainers:
        - name: init-container-test
          image: test:3.2
          command:
            - sleep
            - infinity
      mysql:
        enabled: true
        auth:
          username: test-user
          password: test-password
      backendStore:
        databaseConnectionCheck: true
    asserts:
      - equal:
          path: spec.template.spec.initContainers[0].name
          value: dbchecker
        template: deployment.yaml
      - equal:
          path: spec.template.spec.initContainers[1].name
          value: init-container-test
        template: deployment.yaml

  - it: should have a DB migration init container present if enabled with postgres
    set:
      backendStore:
        databaseMigration: true
        postgres:
          enabled: true
          host: test-host
          database: test-database
          user: test-user
          password: test-password
    asserts:
      - equal:
          path: spec.template.spec.initContainers[0].name
          value: mlflow-db-migration
        template: deployment.yaml

  - it: should have a DB migration init container present if enabled with postgresql
    set:
      postgresql:
        enabled: true
        auth:
          database: test-database
          username: test-user
          password: test-password
      backendStore:
        databaseMigration: true
    asserts:
      - equal:
          path: spec.template.spec.initContainers[0].name
          value: mlflow-db-migration
        template: deployment.yaml

  - it: should have a DB migration init container present if enabled with MySQL
    set:
      backendStore:
        databaseMigration: true
        mysql:
          enabled: true
          host: test-host
          database: test-database
          user: test-user
          password: test-password
    asserts:
      - equal:
          path: spec.template.spec.initContainers[0].name
          value: mlflow-db-migration
        template: deployment.yaml

  - it: should have a DB migration init container present if enabled with bitnami mysql
    set:
      mysql:
        enabled: true
        auth:
          username: test-user
          password: test-password
      backendStore:
        databaseMigration: true
    asserts:
      - equal:
          path: spec.template.spec.initContainers[0].name
          value: mlflow-db-migration
        template: deployment.yaml

  - it: should have a DB migration init container and additional init containers are present with postgres
    set:
      initContainers:
        - name: init-container-test
          image: test:3.2
          command:
            - sleep
            - infinity
      backendStore:
        databaseMigration: true
        postgres:
          enabled: true
          host: test-host
          database: test-database
          user: test-user
          password: test-password
    asserts:
      - equal:
          path: spec.template.spec.initContainers[0].name
          value: mlflow-db-migration
        template: deployment.yaml
      - equal:
          path: spec.template.spec.initContainers[1].name
          value: init-container-test
        template: deployment.yaml

  - it: should have a DB migration init container and additional init containers are present with postgresql
    set:
      initContainers:
        - name: init-container-test
          image: test:3.2
          command:
            - sleep
            - infinity
      postgresql:
        enabled: true
        auth:
          database: test-database
          username: test-user
          password: test-password
      backendStore:
        databaseMigration: true
    asserts:
      - equal:
          path: spec.template.spec.initContainers[0].name
          value: mlflow-db-migration
        template: deployment.yaml
      - equal:
          path: spec.template.spec.initContainers[1].name
          value: init-container-test
        template: deployment.yaml

  - it: should have a DB migration init container and additional init containers are present with MySQL
    set:
      initContainers:
        - name: init-container-test
          image: test:3.2
          command:
            - sleep
            - infinity
      backendStore:
        databaseMigration: true
        mysql:
          enabled: true
          host: test-host
          database: test-database
          user: test-user
          password: test-password
    asserts:
      - equal:
          path: spec.template.spec.initContainers[0].name
          value: mlflow-db-migration
        template: deployment.yaml
      - equal:
          path: spec.template.spec.initContainers[1].name
          value: init-container-test
        template: deployment.yaml

  - it: should have a DB migration init container and additional init containers are present with bitnami MySQL
    set:
      initContainers:
        - name: init-container-test
          image: test:3.2
          command:
            - sleep
            - infinity
      mysql:
        enabled: true
        auth:
          username: test-user
          password: test-password
      backendStore:
        databaseMigration: true
    asserts:
      - equal:
          path: spec.template.spec.initContainers[0].name
          value: mlflow-db-migration
        template: deployment.yaml
      - equal:
          path: spec.template.spec.initContainers[1].name
          value: init-container-test
        template: deployment.yaml

  - it: should have a DB checker init container, DB migration init container and additional init containers are present with postgres
    set:
      initContainers:
        - name: init-container-test
          image: test:3.2
          command:
            - sleep
            - infinity
      backendStore:
        databaseConnectionCheck: true
        databaseMigration: true
        postgres:
          enabled: true
          host: test-host
          database: test-database
          user: test-user
          password: test-password
    asserts:
      - equal:
          path: spec.template.spec.initContainers[0].name
          value: dbchecker
        template: deployment.yaml
      - equal:
          path: spec.template.spec.initContainers[1].name
          value: mlflow-db-migration
        template: deployment.yaml
      - equal:
          path: spec.template.spec.initContainers[2].name
          value: init-container-test
        template: deployment.yaml

  - it: should have a DB checker init container, DB migration init container and additional init containers are present with postgresql
    set:
      initContainers:
        - name: init-container-test
          image: test:3.2
          command:
            - sleep
            - infinity
      backendStore:
        databaseConnectionCheck: true
        databaseMigration: true
      postgresql:
        enabled: true
        auth:
          database: test-database
          username: test-user
          password: test-password
    asserts:
      - equal:
          path: spec.template.spec.initContainers[0].name
          value: dbchecker
        template: deployment.yaml
      - equal:
          path: spec.template.spec.initContainers[1].name
          value: mlflow-db-migration
        template: deployment.yaml
      - equal:
          path: spec.template.spec.initContainers[2].name
          value: init-container-test
        template: deployment.yaml

  - it: should have a DB checker init container, DB migration init container and additional init containers are present with MySQL
    set:
      initContainers:
        - name: init-container-test
          image: test:3.2
          command:
            - sleep
            - infinity
      backendStore:
        databaseConnectionCheck: true
        databaseMigration: true
        mysql:
          enabled: true
          host: test-host
          database: test-database
          user: test-user
          password: test-password
    asserts:
      - equal:
          path: spec.template.spec.initContainers[0].name
          value: dbchecker
        template: deployment.yaml
      - equal:
          path: spec.template.spec.initContainers[1].name
          value: mlflow-db-migration
        template: deployment.yaml
      - equal:
          path: spec.template.spec.initContainers[2].name
          value: init-container-test
        template: deployment.yaml

  - it: should have a DB checker init container, DB migration init container and additional init containers are present with bitnami MySQL
    set:
      initContainers:
        - name: init-container-test
          image: test:3.2
          command:
            - sleep
            - infinity
      mysql:
        enabled: true
        auth:
          username: test-user
          password: test-password
      backendStore:
        databaseConnectionCheck: true
        databaseMigration: true
    asserts:
      - equal:
          path: spec.template.spec.initContainers[0].name
          value: dbchecker
        template: deployment.yaml
      - equal:
          path: spec.template.spec.initContainers[1].name
          value: mlflow-db-migration
        template: deployment.yaml
      - equal:
          path: spec.template.spec.initContainers[2].name
          value: init-container-test
        template: deployment.yaml

  - it: should set liveness probe configurations when we pass it
    set:
      livenessProbe:
        initialDelaySeconds: 0
        periodSeconds: 10
        timeoutSeconds: 1
        failureThreshold: 3
    asserts:
      - equal:
          path: spec.template.spec.containers[?(@.name == "mlflow")].livenessProbe.initialDelaySeconds
          value: 0
        template: deployment.yaml
      - equal:
          path: spec.template.spec.containers[?(@.name == "mlflow")].livenessProbe.periodSeconds
          value: 10
        template: deployment.yaml
      - equal:
          path: spec.template.spec.containers[?(@.name == "mlflow")].livenessProbe.timeoutSeconds
          value: 1
        template: deployment.yaml
      - equal:
          path: spec.template.spec.containers[?(@.name == "mlflow")].livenessProbe.failureThreshold
          value: 3
        template: deployment.yaml

  - it: should set readiness probe configurations when we pass it
    set:
      readinessProbe:
        initialDelaySeconds: 0
        periodSeconds: 10
        timeoutSeconds: 1
        failureThreshold: 3
    asserts:
      - equal:
          path: spec.template.spec.containers[?(@.name == "mlflow")].readinessProbe.initialDelaySeconds
          value: 0
        template: deployment.yaml
      - equal:
          path: spec.template.spec.containers[?(@.name == "mlflow")].readinessProbe.periodSeconds
          value: 10
        template: deployment.yaml
      - equal:
          path: spec.template.spec.containers[?(@.name == "mlflow")].readinessProbe.timeoutSeconds
          value: 1
        template: deployment.yaml
      - equal:
          path: spec.template.spec.containers[?(@.name == "mlflow")].readinessProbe.failureThreshold
          value: 3
        template: deployment.yaml

  - it: should use different port number when we change it
    set:
      service.containerPort: 80
    asserts:
      - contains:
          path: spec.template.spec.containers[?(@.name == "mlflow")].args
          content: --port=80
        template: deployment.yaml
      - equal:
          path: spec.template.spec.containers[?(@.name == "mlflow")].ports[0].containerPort
          value: 80
        template: deployment.yaml

  - it: should use different port name when we change it
    set:
      service.containerPortName: differentname
    asserts:
      - contains:
          path: spec.template.spec.containers[?(@.name == "mlflow")].ports
          content:
            name: differentname
          any: true
        template: deployment.yaml
      - equal:
          path: spec.template.spec.containers[?(@.name == "mlflow")].livenessProbe.httpGet.port
          value: differentname
        template: deployment.yaml
      - equal:
          path: spec.template.spec.containers[?(@.name == "mlflow")].readinessProbe.httpGet.port
          value: differentname
        template: deployment.yaml

  - it: should use authentication settings when auth enabled
    set:
      auth.enabled: true
      auth.appName: my-auth
      auth.configPath: /my/special/path/
    release:
      name: mlflow
      namespace: mlflow
    chart:
      version: 1.0.0
      appVersion: 1.0.0
    asserts:
      - contains:
          path: spec.template.spec.containers[?(@.name == "mlflow")].args
          content: --app-name=my-auth
        template: deployment.yaml
      - contains:
          path: spec.template.spec.containers[?(@.name == "mlflow")].env
          content:
            name: MLFLOW_AUTH_CONFIG_PATH
            value: /my/special/path/basic_auth.ini
        template: deployment.yaml
      - contains:
          path: spec.template.spec.containers[?(@.name == "mlflow")].volumeMounts
          content:
            mountPath: /my/special/path/basic_auth.ini
            name: ini-file
            readOnly: true
            subPath: auth_result.ini
        template: deployment.yaml
      - contains:
          path: spec.template.spec.volumes
          content:
            name: ini-file
            emptyDir: {}
        template: deployment.yaml
      - contains:
          path: spec.template.spec.volumes
          content:
            name: auth-ini-template-file
            configMap:
              name: mlflow-auth-ini-template
        template: deployment.yaml

  - it: should use LDAP authentication settings when ldapAuth enabled
    set:
      ldapAuth.enabled: true
      ldapAuth.uri: "ldap://lldap:3890/dc=mlflow,dc=test"
      ldapAuth.lookupBind: "uid=%s,ou=people,dc=mlflow,dc=test"
      ldapAuth.groupAttribute: "dn"
      ldapAuth.searchBaseDistinguishedName: "ou=groups,dc=mlflow,dc=test"
      ldapAuth.searchFilter: "(&(objectclass=groupOfUniqueNames)(uniquemember=%s))"
      ldapAuth.adminGroupDistinguishedName: "cn=test-admin,ou=groups,dc=mlflow,dc=test"
      ldapAuth.userGroupDistinguishedName: "cn=test-user,ou=groups,dc=mlflow,dc=test"
    release:
      name: mlflow
      namespace: mlflow
    chart:
      version: 1.0.0
      appVersion: 1.0.0
    asserts:
      - contains:
          path: spec.template.spec.containers[?(@.name == "mlflow")].args
          content: --app-name=basic-auth
        template: deployment.yaml
      - contains:
          path: spec.template.spec.containers[?(@.name == "mlflow")].env
          content:
            name: MLFLOW_AUTH_CONFIG_PATH
            value: /etc/mlflow/auth/ldap_basic_auth.ini
        template: deployment.yaml
      - contains:
          path: spec.template.spec.containers[?(@.name == "mlflow")].volumeMounts
          content:
            mountPath: /etc/mlflow/auth/ldap_basic_auth.ini
            name: ini-file
            subPath: auth_result.ini
            readOnly: true
        template: deployment.yaml
      - contains:
          path: spec.template.spec.volumes
          content:
            name: ini-file
            emptyDir: {}
        template: deployment.yaml
      - contains:
          path: spec.template.spec.volumes
          content:
            name: auth-ini-template-file
            configMap:
              name: mlflow-auth-ini-template
        template: deployment.yaml

  - it: should set trusted CA certificate when ldapAuth enabled and encodedTrustedCACertificate is set
    set:
      ldapAuth:
        enabled: true
        encodedTrustedCACertificate: "c29tZXRoaW5n"
    asserts:
      - contains:
          path: spec.template.spec.containers[?(@.name == "mlflow")].env
          content:
            name: LDAP_CA
            value: /certs/ca.crt
        template: deployment.yaml
      - contains:
          path: spec.template.spec.containers[?(@.name == "mlflow")].volumeMounts
          content:
            name: trusted-ca-cert-secret
            mountPath: /certs/ca.crt
            subPath: ca.crt
            readOnly: true
        template: deployment.yaml
      - contains:
          path: spec.template.spec.volumes
          content:
            name: trusted-ca-cert-secret
            secret:
              secretName: mlflow-trusted-ca-cert-secret
        template: deployment.yaml

  - it: should set trusted CA certificate when ldapAuth enabled and externalSecretForTrustedCACertificate is set
    set:
      ldapAuth:
        enabled: true
        externalSecretForTrustedCACertificate: "test-secret"
    asserts:
      - contains:
          path: spec.template.spec.containers[?(@.name == "mlflow")].env
          content:
            name: LDAP_CA
            value: /certs/ca.crt
        template: deployment.yaml
      - contains:
          path: spec.template.spec.containers[?(@.name == "mlflow")].volumeMounts
          content:
            name: trusted-ca-cert-secret
            mountPath: /certs/ca.crt
            subPath: ca.crt
            readOnly: true
        template: deployment.yaml
      - contains:
          path: spec.template.spec.volumes
          content:
            name: trusted-ca-cert-secret
            secret:
              secretName: test-secret
        template: deployment.yaml

  - it: should set replicas when autoscaling is not enabled
    set:
      autoscaling.enabled: false
    asserts:
      - equal:
          path: spec.replicas
          value: 1
        template: deployment.yaml

  - it: should not set replicas when autoscaling is enabled
    set:
      autoscaling.enabled: true
    asserts:
      - notEqual:
          path: spec.replicas
          value: 1
        template: deployment.yaml

  - it: should use username and password from existing secret when backendStore.existingDatabaseSecret is set and postgres is enabled
    set:
      backendStore:
        existingDatabaseSecret:
          name: test-secret
          usernameKey: customUsername
          passwordKey: customPassword
        postgres:
          enabled: true
          host: test-host
          database: test-database
    asserts:
      - contains:
          path: spec.template.spec.containers[?(@.name == "mlflow")].env
          content:
            name: PGUSER
            valueFrom:
              secretKeyRef:
                name: test-secret
                key: customUsername
        template: deployment.yaml
      - contains:
          path: spec.template.spec.containers[?(@.name == "mlflow")].env
          content:
            name: PGPASSWORD
            valueFrom:
              secretKeyRef:
                name: test-secret
                key: customPassword
        template: deployment.yaml

  - it: should use username and password from existing secret when backendStore.existingDatabaseSecret is set and mysql is enabled
    set:
      backendStore:
        existingDatabaseSecret:
          name: test-secret
          usernameKey: customUsername
          passwordKey: customPassword
        mysql:
          enabled: true
          host: test-host
          database: test-database
    asserts:
      - contains:
          path: spec.template.spec.containers[?(@.name == "mlflow")].env
          content:
            name: MYSQL_USERNAME
            valueFrom:
              secretKeyRef:
                name: test-secret
                key: customUsername
        template: deployment.yaml
      - contains:
          path: spec.template.spec.containers[?(@.name == "mlflow")].env
          content:
            name: MYSQL_PWD
            valueFrom:
              secretKeyRef:
                name: test-secret
                key: customPassword
        template: deployment.yaml

  - it: should use username and password from existing secret when backendStore.existingDatabaseSecret is set and postgres is enabled and database check connection is enabled
    set:
      backendStore:
        databaseConnectionCheck: true
        postgres:
          enabled: true
          host: test-host
          database: test-database
        existingDatabaseSecret:
          name: test-secret
          usernameKey: customUsername
          passwordKey: customPassword
    asserts:
      - contains:
          path: spec.template.spec.initContainers[?(@.name == "dbchecker")].env
          content:
            name: PGUSER
            valueFrom:
              secretKeyRef:
                name: test-secret
                key: customUsername
        template: deployment.yaml
      - contains:
          path: spec.template.spec.initContainers[?(@.name == "dbchecker")].env
          content:
            name: PGPASSWORD
            valueFrom:
              secretKeyRef:
                name: test-secret
                key: customPassword
        template: deployment.yaml

  - it: should use username and password from existing secret when backendStore.existingDatabaseSecret is set and mysql is enabled and database check connection is enabled
    set:
      backendStore:
        databaseConnectionCheck: true
        mysql:
          enabled: true
          host: test-host
          database: test-database
        existingDatabaseSecret:
          name: test-secret
          usernameKey: customUsername
          passwordKey: customPassword
    asserts:
      - contains:
          path: spec.template.spec.initContainers[?(@.name == "dbchecker")].env
          content:
            name: MYSQL_USERNAME
            valueFrom:
              secretKeyRef:
                name: test-secret
                key: customUsername
        template: deployment.yaml
      - contains:
          path: spec.template.spec.initContainers[?(@.name == "dbchecker")].env
          content:
            name: MYSQL_PWD
            valueFrom:
              secretKeyRef:
                name: test-secret
                key: customPassword
        template: deployment.yaml

  - it: should use username and password from existing secret when backendStore.existingDatabaseSecret is set and postgres is enabled and database migration is enabled
    set:
      backendStore:
        databaseMigration: true
        postgres:
          enabled: true
          host: test-host
          database: test-database
        existingDatabaseSecret:
          name: test-secret
          usernameKey: customUsername
          passwordKey: customPassword
    asserts:
      - contains:
          path: spec.template.spec.initContainers[?(@.name == "mlflow-db-migration")].env
          content:
            name: PGUSER
            valueFrom:
              secretKeyRef:
                name: test-secret
                key: customUsername
        template: deployment.yaml
      - contains:
          path: spec.template.spec.initContainers[?(@.name == "mlflow-db-migration")].env
          content:
            name: PGPASSWORD
            valueFrom:
              secretKeyRef:
                name: test-secret
                key: customPassword
        template: deployment.yaml

  - it: should use username and password from existing secret when backendStore.existingDatabaseSecret is set and mysql is enabled and database migration is enabled
    set:
      backendStore:
        databaseMigration: true
        mysql:
          enabled: true
          host: test-host
          database: test-database
        existingDatabaseSecret:
          name: test-secret
          usernameKey: customUsername
          passwordKey: customPassword
    asserts:
      - contains:
          path: spec.template.spec.initContainers[?(@.name == "mlflow-db-migration")].env
          content:
            name: MYSQL_USERNAME
            valueFrom:
              secretKeyRef:
                name: test-secret
                key: customUsername
        template: deployment.yaml
      - contains:
          path: spec.template.spec.initContainers[?(@.name == "mlflow-db-migration")].env
          content:
            name: MYSQL_PWD
            valueFrom:
              secretKeyRef:
                name: test-secret
                key: customPassword
        template: deployment.yaml

  - it: should set extra pod labels for AKS workload identity when the labels are set
    set:
      extraPodLabels:
        "azure.workload.identity/use": "true"
    asserts:
      - equal:
          path: spec.template.metadata.labels["azure.workload.identity/use"]
          value: "true"
        template: deployment.yaml

  - it: should set AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY from existing secret when existing secret name, keyOfAccessKeyId and keyOfSecretAccessKey fields set
    set:
      artifactRoot:
        s3:
          enabled: true
          bucket: test-bucket
          existingSecret:
            name: my-aws-existing-secret
            keyOfAccessKeyId: awsAccessKeyId
            keyOfSecretAccessKey: awsSecretAccessKey
    asserts:
      - contains:
          path: spec.template.spec.containers[?(@.name == "mlflow")].env
          content:
            name: AWS_ACCESS_KEY_ID
            valueFrom:
              secretKeyRef:
                name: my-aws-existing-secret
                key: awsAccessKeyId
        template: deployment.yaml
      - contains:
          path: spec.template.spec.containers[?(@.name == "mlflow")].env
          content:
            name: AWS_SECRET_ACCESS_KEY
            valueFrom:
              secretKeyRef:
                name: my-aws-existing-secret
                key: awsSecretAccessKey
        template: deployment.yaml

  - it: should match snapshot of default values
    release:
      name: mlflow
      namespace: mlflow
    chart:
      version: 1.0.0
      appVersion: 1.0.0
    asserts:
      - matchSnapshot: { }

  - it: should match snapshot with additional values
    set:
      auth:
        enabled: true
      backendStore:
        databaseMigration: true
        databaseConnectionCheck: true
        postgres:
          enabled: true
          host: test-host
          database: test-database
          user: test-user
          password: test-password
      podAnnotations:
        test-key: test-value
      extraPodLabels:
        "azure.workload.identity/use": "true"
      podSecurityContext:
        fsGroup: 1001
      securityContext:
        runAsNonRoot: true
        runAsUser: 1001
      initContainers:
        - name: init-myservice
          image: busybox:1.28
      resources:
        limits:
          cpu: 100m
          memory: 128Mi
        requests:
          cpu: 100m
          memory: 128Mi
      extraVolumeMounts:
        - name: mlflow-volume
          mountPath: /mlflow/data
        - name: example
          mountPath: /example
      extraVolumes:
        - name: mlflow-volume
          persistentVolumeClaim:
            claimName: mlflow-pv-volume
        - name: example
          configMap:
            name: example
      nodeSelector:
        disktype: ssd
      affinity:
        nodeAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
            nodeSelectorTerms:
              - matchExpressions:
                  - key: kubernetes.io/e2e-az-name
                    operator: In
                    values:
                      - e2e-az1
                      - e2e-az2
          preferredDuringSchedulingIgnoredDuringExecution:
            - weight: 1
              preference:
                matchExpressions:
                  - key: custom-key
                    operator: In
                    values:
                      - custom-value
      tolerations:
        - key: "example-key"
          operator: "Exists"
          effect: "NoSchedule"
    release:
      name: mlflow
      namespace: mlflow
    chart:
      version: 1.0.0
      appVersion: 1.0.0
    asserts:
      - matchSnapshot: { }

  - it: should match snapshot with additional values when postgresql is enabled
    set:
      auth:
        enabled: true
      backendStore:
        databaseMigration: true
        databaseConnectionCheck: true
        postgres:
          enabled: true
          host: test-host
          database: test-database
          user: test-user
          password: test-password
      podAnnotations:
        test-key: test-value
      extraPodLabels:
        "azure.workload.identity/use": "true"
      podSecurityContext:
        fsGroup: 1001
      securityContext:
        runAsNonRoot: true
        runAsUser: 1001
      initContainers:
        - name: init-myservice
          image: busybox:1.28
      resources:
        limits:
          cpu: 100m
          memory: 128Mi
        requests:
          cpu: 100m
          memory: 128Mi
      extraVolumeMounts:
        - name: mlflow-volume
          mountPath: /mlflow/data
        - name: example
          mountPath: /example
      extraVolumes:
        - name: mlflow-volume
          persistentVolumeClaim:
            claimName: mlflow-pv-volume
        - name: example
          configMap:
            name: example
      nodeSelector:
        disktype: ssd
      affinity:
        nodeAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
            nodeSelectorTerms:
              - matchExpressions:
                  - key: kubernetes.io/e2e-az-name
                    operator: In
                    values:
                      - e2e-az1
                      - e2e-az2
          preferredDuringSchedulingIgnoredDuringExecution:
            - weight: 1
              preference:
                matchExpressions:
                  - key: custom-key
                    operator: In
                    values:
                      - custom-value
      tolerations:
        - key: "example-key"
          operator: "Exists"
          effect: "NoSchedule"
    release:
      name: mlflow
      namespace: mlflow
    chart:
      version: 1.0.0
      appVersion: 1.0.0
    asserts:
      - matchSnapshot: { }

  - it: should match snapshot with additional values when bitnami postgresql is enabled
    set:
      auth:
        enabled: true
      backendStore:
        databaseMigration: true
        databaseConnectionCheck: true
      postgresql:
        enabled: true
        auth:
          database: test-database
          username: test-user
          password: test-password
      podAnnotations:
        test-key: test-value
      extraPodLabels:
        "azure.workload.identity/use": "true"
      podSecurityContext:
        fsGroup: 1001
      securityContext:
        runAsNonRoot: true
        runAsUser: 1001
      initContainers:
        - name: init-myservice
          image: busybox:1.28
      resources:
        limits:
          cpu: 100m
          memory: 128Mi
        requests:
          cpu: 100m
          memory: 128Mi
      extraVolumeMounts:
        - name: mlflow-volume
          mountPath: /mlflow/data
        - name: example
          mountPath: /example
      extraVolumes:
        - name: mlflow-volume
          persistentVolumeClaim:
            claimName: mlflow-pv-volume
        - name: example
          configMap:
            name: example
      nodeSelector:
        disktype: ssd
      affinity:
        nodeAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
            nodeSelectorTerms:
              - matchExpressions:
                  - key: kubernetes.io/e2e-az-name
                    operator: In
                    values:
                      - e2e-az1
                      - e2e-az2
          preferredDuringSchedulingIgnoredDuringExecution:
            - weight: 1
              preference:
                matchExpressions:
                  - key: custom-key
                    operator: In
                    values:
                      - custom-value
      tolerations:
        - key: "example-key"
          operator: "Exists"
          effect: "NoSchedule"
    release:
      name: mlflow
      namespace: mlflow
    chart:
      version: 1.0.0
      appVersion: 1.0.0
    asserts:
      - matchSnapshot: { }

  - it: should match snapshot with additional values when mysql is enabled
    set:
      auth:
        enabled: true
      backendStore:
        databaseMigration: true
        databaseConnectionCheck: true
        mysql:
          enabled: true
          host: test-host
          database: test-database
          user: test-user
          password: test-password
      podAnnotations:
        test-key: test-value
      extraPodLabels:
        "azure.workload.identity/use": "true"
      podSecurityContext:
        fsGroup: 1001
      securityContext:
        runAsNonRoot: true
        runAsUser: 1001
      initContainers:
        - name: init-myservice
          image: busybox:1.28
      resources:
        limits:
          cpu: 100m
          memory: 128Mi
        requests:
          cpu: 100m
          memory: 128Mi
      extraVolumeMounts:
        - name: mlflow-volume
          mountPath: /mlflow/data
        - name: example
          mountPath: /example
      extraVolumes:
        - name: mlflow-volume
          persistentVolumeClaim:
            claimName: mlflow-pv-volume
        - name: example
          configMap:
            name: example
      nodeSelector:
        disktype: ssd
      affinity:
        nodeAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
            nodeSelectorTerms:
              - matchExpressions:
                  - key: kubernetes.io/e2e-az-name
                    operator: In
                    values:
                      - e2e-az1
                      - e2e-az2
          preferredDuringSchedulingIgnoredDuringExecution:
            - weight: 1
              preference:
                matchExpressions:
                  - key: custom-key
                    operator: In
                    values:
                      - custom-value
      tolerations:
        - key: "example-key"
          operator: "Exists"
          effect: "NoSchedule"
    release:
      name: mlflow
      namespace: mlflow
    chart:
      version: 1.0.0
      appVersion: 1.0.0
    asserts:
      - matchSnapshot: { }

  - it: should match snapshot with additional values when bitnami mysql is enabled
    set:
      auth:
        enabled: true
      backendStore:
        databaseMigration: true
        databaseConnectionCheck: true
      mysql:
        enabled: true
        auth:
          database: test-database
          username: test-user
          password: test-password
      podAnnotations:
        test-key: test-value
      extraPodLabels:
        "azure.workload.identity/use": "true"
      podSecurityContext:
        fsGroup: 1001
      securityContext:
        runAsNonRoot: true
        runAsUser: 1001
      initContainers:
        - name: init-myservice
          image: busybox:1.28
      resources:
        limits:
          cpu: 100m
          memory: 128Mi
        requests:
          cpu: 100m
          memory: 128Mi
      extraVolumeMounts:
        - name: mlflow-volume
          mountPath: /mlflow/data
        - name: example
          mountPath: /example
      extraVolumes:
        - name: mlflow-volume
          persistentVolumeClaim:
            claimName: mlflow-pv-volume
        - name: example
          configMap:
            name: example
      nodeSelector:
        disktype: ssd
      affinity:
        nodeAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
            nodeSelectorTerms:
              - matchExpressions:
                  - key: kubernetes.io/e2e-az-name
                    operator: In
                    values:
                      - e2e-az1
                      - e2e-az2
          preferredDuringSchedulingIgnoredDuringExecution:
            - weight: 1
              preference:
                matchExpressions:
                  - key: custom-key
                    operator: In
                    values:
                      - custom-value
      tolerations:
        - key: "example-key"
          operator: "Exists"
          effect: "NoSchedule"
    release:
      name: mlflow
      namespace: mlflow
    chart:
      version: 1.0.0
      appVersion: 1.0.0
    asserts:
      - matchSnapshot: { }

  - it: should match snapshot with additional values when auth and auth.postgres are enabled
    set:
      auth:
        enabled: true
        adminUsername: auth-admin
        adminPassword: auth-password
        postgres:
          enabled: true
          host: auth-pg-host
          database: auth
          user: pg-auth-user
          password: pg-auth-password
      backendStore:
        databaseMigration: true
        databaseConnectionCheck: true
        postgres:
          enabled: true
          host: test-host
          database: test-database
          user: test-user
          password: test-password
      podAnnotations:
        test-key: test-value
      extraPodLabels:
        "azure.workload.identity/use": "true"
      podSecurityContext:
        fsGroup: 1001
      securityContext:
        runAsNonRoot: true
        runAsUser: 1001
      initContainers:
        - name: init-myservice
          image: busybox:1.28
      resources:
        limits:
          cpu: 100m
          memory: 128Mi
        requests:
          cpu: 100m
          memory: 128Mi
      extraVolumeMounts:
        - name: mlflow-volume
          mountPath: /mlflow/data
        - name: example
          mountPath: /example
      extraVolumes:
        - name: mlflow-volume
          persistentVolumeClaim:
            claimName: mlflow-pv-volume
        - name: example
          configMap:
            name: example
      nodeSelector:
        disktype: ssd
      affinity:
        nodeAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
            nodeSelectorTerms:
              - matchExpressions:
                  - key: kubernetes.io/e2e-az-name
                    operator: In
                    values:
                      - e2e-az1
                      - e2e-az2
          preferredDuringSchedulingIgnoredDuringExecution:
            - weight: 1
              preference:
                matchExpressions:
                  - key: custom-key
                    operator: In
                    values:
                      - custom-value
      tolerations:
        - key: "example-key"
          operator: "Exists"
          effect: "NoSchedule"
    release:
      name: mlflow
      namespace: mlflow
    chart:
      version: 1.0.0
      appVersion: 1.0.0
    asserts:
      - matchSnapshot: { }
